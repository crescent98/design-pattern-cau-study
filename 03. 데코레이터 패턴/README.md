# 데코레이터 패턴

- 참석자 및 작성자: 강시후, 문상헌, 유호성
- 스터디 일자: 2022/05/01

> **객체 꾸미기**
> 
- 기존 객체에 기능을 추가(삭제)하기 위해 사용할 수 있는 패턴
- 꾸밈 받는 객체, 꾸미기 위한 객체(데코레이터)로 구성할 수 있음
- 꾸밈 받는 객체와 데코레이터가 모두 같은 객체 타입을 가지는 것이 큰 특징 중 하나. 상위 인터페이스가 존재해야 함

***데코레이터 패턴은 언제 사용하는가?***

다른 객체에서 같은 행동(메서드)이 반복되어 사용될 떄 사용하면 유용하다.

책에서 소개된 `cost()`의 경우, 우유, 모카커피, 다크로스트 커피 등등 모든 메뉴에서 `cost()`가 사용되기 때문에 이를 재사용 가능하도록 처리했다.

이는 결국 변경에 닫혀있고, 확장에는 열려있어야 한다는 디자인 원칙에 잘 부합한다.

## 예시

- 상위 인터페이스: 전송 서비스를 구현하기 위한 인터페이스 정의

```java
interface SendService {
    void doSend(String userId);
}
```

- 꾸밈 받는 객체: 전송 서비스를 실제로 구현함

```java
public class SendServiceImpl implements SendService {
    
    @Override
    void doSend(String userId) {
        
        // do send
    }
}
```

- 데코레이터: SendService를 구현하고 있는 것이 핵심이며, 인스턴스 필드로 본래 SendServiceImpl을 가지고 있어야 함

```java
public class SendServiceDecorator implements SendService {
    
    SendService sendServiceImpl;

    @Override
    void doSend(String userId) {
        // 1. 실제 service 호출 전, 전송하는 사용자의 권한을 체크한다.
        if(!isValid(userId)) // throw exception

        // 2. 실제 서비스 호출
        sendServiceImpl.doSend();
    }
}
```

- 서비스 호출

```java
public static void main(String[] args) {
    sendService.doSend("1L");
}
```

데코레이터 적용 전, 단순히 사용자 -> 전송 서비스 호출이었음.

이 후 ***사용자 전송 서비스 이용 권한을 체크하라는 요구사항이 추가됐을 때***

데코레이터를 추가하기만 하면 SendService 호출 코드, SendServiceImpl 등 기존 코드가 변화될 것은 아무것도 없이 권한 체크 기능을 성공적으로 추가할 수 있음 (물론 스프링 의존성 주입과 함께 해야함)

### **OCP(Open-Closed Principle)**

클래스는 확장에는 열려 있어야 하지만, 변경에는 닫혀 있어야 한다.

### 데코레이터 패턴의 장점

기존 코드를 수정하지 않고 행동을 확장할 수 있다(OCP)는 장점이 있다.

### 데코레이터 패턴의 단점

데코레이터 패턴은 상속을 한다는 점에서 유연성이 좋다고 할 수는 없다. 또한 데코레이터를 도입하면 구성 요소를 초기화하는 데 필요한 코드가 훨씬 복잡해진다는 단점이 있다.

---

## 의논한 부분

pg. 127

> **상속과 데코레이터 패턴의 차이를 인지하면서 알아두면 좋을 것 같음**
> 

상속의 행위가 일어나기는 하지만, 데코레이터 형식이 그 데코레이터로 감싸는 객체의 형식과 같다는 점이 중요한 부분

실행 중에 데코레이터를 마음대로 조합해서 사용할 수 있다는 장점

→ 쉽게 변경 가능

*핵심적인 것은 상속은 받았지만 호출 이전에 꾸며주는 역할을 수행하는 게 중요한 게 아닌가*

그전 객체에 대한 정보 없이 데코레이팅에서 하는 행위만 작성하면 됨 (추가 기능) → 확장에는 열려 있다

상속받은 것을 직접 변경하지 않고 행동을 추가한다는 점에서 다르다.

특히 상속만 사용한다면 행동이 컴파일 시에 정적으로 결정되어 버리기 때문에 오직 오버라이드 한 것만 사용할 수 있다.

하지만 구성(Composition)을 활용하면 실행 중에 데코레이터를 마음대로 조합해서 사용할 수 있다.

+@

***python에서 메소드를 오버라이딩할 경우 부모클래스의 메소드를 실행하는 것과 데코레이터 패턴의 공통점, 차이점***

python 에서는 한번의 오버라이딩이 나타나는가 하면 데코레이터는 연쇄적으로 반복해서 발생