# 디자인 패턴 소개와 전략 패턴

# 전략 패턴

행동이 교환 가능하도록 정의, 캡슐화하고 사용

동작을 각각의 전략으로서 클래스로 만들고, 행동을 변경해야 한다면, 전략만 변경

인터페이스에 맞춰서 프로그래밍을 한다

→ 객체가 코드에 고정되지 않도록 상위형식에 맞춰서 프로그래밍하기

***→ 아래에서 위 (단순히 메소드를 넣고 overriding 하는 경우) 가 아니라 위에서 아래로***s

- 전략 패턴은 알고리즘군을 정의하고 캡슐화해서 각각의 알고리즘군을 수정해서 쓸 수 있게 함
- 전략 패턴을 사용하면 클라이언트로부터 알고리즘을 분리해서 독립적으로 변경 가능

예시: 

오리가 나는 것을 표현하기 위해서는 그 행동을 단순히 하위 클래스에 메소드로 표현하지 않고

**다른 클래스에 그 행동을 위임**

### 구성

A에는 B가 있다 → B 라는 행동을 따로 클래스로 위임 → 두 클래스를 합치면서 구현

A 클래스 입장에서는 행동을 상속 받게 되면서 올바른 **행동 객체로 구성되어 행동을 부여받음**

디자인 원칙 → 상속보다는 구성을 활용한다

**구성의 장점**

- 유연성을 크게 향상 시킬 수 있음
- 단순한 알고리즘군(구현)을 별도의 클래스 집합으로 캡슐화
- 구성 요소로 사용하는 객체에서 올바른 행동 인터페이스를 구현하면 **실행 시에 행동을 바꿀 수 있음**

### 이야기 나누면 좋은 것들

*각자 개발할 때 어떤 식으로 개발을 하는지? 디자인 패턴에 대해서 신경을 쓰는지?*

***실행 시에 행동을 바꾼다는 것이 런타임에서 행동을 바꾼다는 건지?***

*요구 사항이 들어왔을 때, 상위 인터페이스를 어떻게 하는 것이 좋을지*

*잠재적인 요구 사항에 대해서 전략 패턴을 어떻게 처리?*

*Mixin 이랑 관련성이 있으려나?*

---

# 옵저버 패턴

한 객체의 상태가 바뀌면 객체에 의존하는 다른 객체에게 연락이 가고 자동으로 내용이 갱신되는 방식

일대다(one-to-many) 의존성

### Louse Coupling (느슨한 결합)

의존성은 있지만 서로를 잘 모르는 관계

주제는 옵저버가 특정 인터페이스를 구현한다는 사실만 알음

주제 위에 옵저버가 있기 때문에 옵저버의 추가시 변경시 주제에 영향 X

> 상호작용하는 객체 사이에는 가능하면 느슨한 결합을 사용해야 한다
> 

### 느낀 점

(개인적인 경험) → 기존에는 event-driven 개발을 거의 하지 않았음

GUI 라고 해봤자 슬랙봇 정도여서 사용할 필요성을 못 느꼈던 것 같음

event 위주의 애플리케이션 개발을 할 때 유용할 것 같다

### 이야기 나누고 싶은 점

X