# 전략 패턴
- 알고리즘 군을 정의하고 캡슐화해서 각각의 알고리즘 군을 수정해서 쓸 수 있게 하는 패턴
- 알고리즘 사이의 공통점을 인터페이스화 하고 차이점은 세부 구현에서 표현함으로써 유연한 코드를 작성할 수 있음.

## 예시

```java
public inferface Walk {
    void do();
}

class ForwardWalk implements Walk {
    
    @Override
    void do() {
        // walk forwards
    }
}

class BackwardWalk implements Walk {
    @Override
    void do() {
        // walk backwards
    }
}

class SidewayWalk implements Walk {
    @Override
    void do() {
        // walk sideways
    }
}
```

- '걷다' 라는 행동을 알고리즘 군으로 정의하고, 걷는 행위라는 공통점을 인터페이스로 정의하고, 구체적인 방식의 차이에 따라 인터페이스를 구현하였음.


```java

@AllArgsConstructor
public class Robot {

    @Setter
    private Walk walkAction;


    public sampleAction() {
        // sleep

        // wake up

        // 주입받는 전략에 따라 다른 행동을 취할 수 있음.
        walkAction.do();
    }

    public static void main(String args[]){
        Robot robot = new Robot(new BackwardWalk());

        robot.sampleAction();
    }
   
}

```
- 로봇 클래스를 정의하고 로봇의 샘플 동작을 sampleAction 메소드에 구현함. 
- 이 때, sampleAction 중 walk 동작은 주입받는 전략에 따라 달라질 수 있음. 로봇의 걷기 방식을 변경하더라도 로봇 클래스는 전혀 변경될 일이 없음
- 추가적으로, 로봇이 취할 수 있는 다른 행동 또한 전략 패턴을 사용해서 추상화하고 행동 전략들의 Composition을 통해 로봇 행동을 표현할 수 있음. 

- 전략 패턴이 없었다면? 로봇 객체의 걷는 행위가 바뀔 때 마다 로봇 클래스의 코드를 일일히 수정해야 함.


# 옵저버 패턴

- 한 객체의 상태가 바뀌면 그 객체에 의존하는 다른 객체에게 연락이 가고 자동으로 내용이 갱신되는 방식으로 일대다 의존성을 정의함.
- 객체 사이의 '느슨한 결합'을 바탕으로 특정 객체의 변화에 의존하는 다른 객체가 유연하게 대비할 수 있음.


## 예시
```java 

public class Newspaper implements Subject {
    private List<Observer> observers;
    private List<News> newsList;


    public void publish(News news) {
        newsList.add(news);

        notifyObservers(news); // Observer에게 연락하기.
    }


    public void notifyObservers(News news) {
        observers.forEach(obs -> obs.update(news));
    }

    public void registerObservers(Observer observer) {
        observers.add(observer);
    }
}

```

- 신문사 객체 (Newspaper)를 정의했고, 여기서 옵저버는 신문 구독자라고 할 수 있음.
- 신문 구독자는 registerObservers 메소드를 통해 구독하며, 신문사는 구독자에 대한 구체적인 정보는 아무것도 모름. (느슨한 결합의 일종..) 

- 신문사가 publish(news)를 통해 신문을 출판하면, publish() 내부에서 notifyObservers()를 호출하여 새로 출판된 뉴스를 구독자들에게 전달함.

- 신문사와 구독자는 서로의 구체적인 내용이 변경되더라도 서로에게 영향을 미치지 않음. (notifyObserver의 형식만 유지한다면)

- 신문사가 구독자에게 직접 전달하는 방법(push), 구독자가 특정 장소에 놓여진 신문을 가져가는 방식(pull) 방법으로 구현할 수 있음. (예시에서는 push 방식이라 할 수 있겠다.) 단, 두 방식 모두 신문사가 새로운 출판에 대한 알림을 주는 것은 필수적이다.


- 옵저버 패턴이 없었다면? 스파게티가 되겠지,,,