## 데코레이터 패턴
---
1. 데코레이터 패턴은 언제 사용하는가?

다른 객체에서 같은 행동(메서드)이 반복되어 사용될 떄 사용하면 유용하다.

책에서 소개된 cost()의 경우, 우유, 모카커피, 다크로스트 커피 등등 모든 메뉴에서 cost()가 사용되기 때문에 이를 재사용 가능하도록 처리했다.

이는 결국 변경에 닫혀있고, 확장에는 열려있어야 한다는 디자인 원칙에 잘 부합한다. 

#### OCP(Open-Closed Principle) 
클래스는 확장에는 열려 있어야 하지만, 변경에는 닫혀 있어야 한다.



2. 데코레이터 패턴과 상속의 차이점은 무엇인가?

데코레이터 패턴은 기본적으로 상속을 사용한다. 상속받은 것을 직접 변경하지 않고 행동을 추가한다는 점에서 다르다.

특히 상속만 사용한다면 행동이 컴파일 시에 정적으로 결정되어 버리기 때문에 오직 오버라이드 한 것만 사용할 수 있다. 하지만 구성을 활용하면 실행 중에 데코레이터를 마음대로 조합해서 사용할 수 있다.

3. 데코레이터 패턴이 장점/단점은 무엇인가?

기존 코드를 수정하지 않고 행동을 확장할 수 있다는 장점이 있다.

데코레이터 패턴은 상속을 한다는 점에서 유연성이 좋다고 할 수는 없다.
또한 데코레이터를 도입하면 구성 요소를 초기화하는 데 필요한 코드가 훨씬 복잡해진다는 단점이 있다.

## 팩토리 패턴
---
1. 팩토리 패턴을 언제 사용하는가?

무분별한 객체 생성을 막고, 객체 생성의 관심사를 분리하기 위해서 사용한다.

즉 객체를 생성하는 역할은 팩토리 메서드가 전담하게 한다.


2. 팩토리 메서드 패턴과 추상 팩터리 패턴의 차이점은 무엇인가?

팩토리 메서드 패턴 : M
추상 팩터리 패턴 : A

M은 클래스를 사용해서 제품(객체)을 생성하고,A는 객체를 써서 제품을 생성한다.

M은 상속으로 객체를 만들지만, A는 객체 구성으로 객체를 만든다.

M은 메서드 오버라이드 이용해서 서브클래스를 객체로 만들려하고,
A는 인스턴스를 만들어 코드에 전달하는 방식을 사용한다. (구성을 사용)

A는 추상클래스를 사용하기 때문에 새로운 제품(새로운 객체)을 만드려면  인터페이스를 바꿔야하지만, M은 추상 생산자에서 코드를 구현하기에 코드 작성에 매우 유연하다.


